# Language definition
--langdef=ATS
--map-ATS=+.dats
--map-ATS=+.sats
--map-ATS=+.hats

# Kind definitions
# pattern: <letter>,<name>,<description>
--kinddef-ATS=f,function,function
--kinddef-ATS=t,type,type
--kinddef-ATS=c,constant,constant
--kinddef-ATS=p,proof,proof


# Ignore comments
# --regex-ATS=/^[[:blank:]]*\/\/.*//{exclusive}
# Ignore single-line block comments. Unfortunately, it doesn't seem easy to ignore
# multiline block comments
# --regex-ATS=/^[[:blank:]]*\(\*[^\*\)]*\*\).*//{exclusive}

# Function definitions
--mline-regex-ATS=/^fun[[:space:]]*(\{[[:space:]]*[^\}]*[[:space:]]*\})*[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\[\{]/\2/f/
--mline-regex-ATS=/^fn[[:space:]]*(\{[[:space:]]*[^\}]*[[:space:]]*\})*[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\[\{]/\2/f/
--mline-regex-ATS=/^castfn[[:space:]]*(\{[[:space:]]*[^\}]*[[:space:]]*\})*[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\[\{]/\2/f/
--mline-regex-ATS=/^prfun[[:space:]]*(\{[[:space:]]*[^\}]*[[:space:]]*\})*[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\[\{]/\2/f/
--mline-regex-ATS=/^prfn[[:space:]]*(\{[[:space:]]*[^\}]*[[:space:]]*\})*[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\[\{]/\2/f/
--mline-regex-ATS=/^fnx[[:space:]]*(\{[[:space:]]*[^\}]*[[:space:]]*\})*[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\[\{]/\2/f/
# --regex-ATS=/^and *([[:lower:]][[:alnum:]_]+)[[:blank:]]*[\(\[\{)]/\1/f/
--mline-regex-ATS=/^implement[[:space:]]*(\{[[:space:]]*[^\}]*[[:space:]]*\})*(\([^\)]*\))*[[:space:]]*([[:alnum:]\$_]+)[[:space:]]*[\(\[\{\<]/\3/f/

# Constant definitions
# (only trying to parse constant forward declarations)
--mline-regex-ATS=/^val[[:space:]]*([[:alnum:]_]+)[[:space:]]*\:/\1/c/

# Type and constant definitions
--mline-regex-ATS=/^typedef[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/
--mline-regex-ATS=/^datatype[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/
--mline-regex-ATS=/^sortdef[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/
--mline-regex-ATS=/^propdef[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/
--mline-regex-ATS=/^viewtypedef[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/
--mline-regex-ATS=/^vtypedef[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/
--mline-regex-ATS=/^dataviewtype[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/
--mline-regex-ATS=/^datavtype[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/t/

# Proof definitions
--mline-regex-ATS=/^praxi[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\{\=\:]/\1/p/
# --regex-ATS=/^prval *([[:lower:]][[:alnum:]_]+)[[:blank:]]*[\(\[\{)]/\1/p/
--mline-regex-ATS=/^dataprop[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/p/
--mline-regex-ATS=/^absviewtype[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/p/
--mline-regex-ATS=/^absvtype[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/p/
--mline-regex-ATS=/^abstype[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/p/
--mline-regex-ATS=/^absprop[[:space:]]*([[:alnum:]_]+)[[:space:]]*[\(\=\:]/\1/p/
